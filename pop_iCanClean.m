% pop_iCanClean() - perform EEG artifact removal using iCanClean algorithm.
%                If less than three arguments are given, a window pops up
%                to ask for the value of the additional parameters.   
%
% Usage:
%   >>  OUTEEG = pop_iCanClean(EEG, 1); % pop-up window asking for parameters
%   >>  OUTEEG = pop_iCanClean(EEG, 1, 'key', 'val', ...) % no window
%
% Inputs:
%   EEG     - input EEG dataset
%   type    - type of processing. 1 process the raw
%             data and 0 the ICA components.
%
% Optional inputs:
%   'EEG_chans'             - list of indices for channels to be cleaned
%   'Noise_chans'           - list of indices for reference noise channels
%   'visualizeResults'      - [0|1] turn off/on graphs to visualize results
%   'rerefX'                - ['no'|'yes-temp'] option to perform average 
%                             re-referencing on X channels. -temp option 
%                             saves re-referenced channels as a separate 
%                             variable.
%   'rerefY'                - ['no'|'yes-temp'] option to perform average 
%                             re-referencing on Y channels. -temp option 
%                             saves re-referenced channels as a separate 
%                             variable.
%   'cleanXwith'            - ['X'|'Y'|'XY'] defines which noise sources to 
%                             use to clean each of the original channels
%                             (X, Y, or a mixture of both)
%   'cleanYwith'            - ['X'|'Y'|'XY'|'no'] defines which noise sources to 
%                             use to clean each of the original channels
%                             (X, Y, or a mixture of both). setting to 'no'
%                             turns off/on Y cleaning
%   'cleanWindow'           - length of the cleaning window, in seconds
%   'statsWindow'           - length of the stats window, in seconds
%   'RTBool'                - [0|1] turn off/on real-time simulation
%   'rhoSqThres_source'     - defines threshold for r^2 cutoff.
%   'giveCleaningUpdates'   - [0|1] turn off/on cleaning updates
%   'plotStatsOn'           - [0|1] turn off/on stats plots
%   'calcCCAonWholeData'    - [0|1] turn off/on option to use CCA to
%                             calculate noise sources
%   'useExternCalibData'    - [0|1] turn off/on option to use external
%                             calibration data
%   'indExternCalibData'    - integer index of ALLEEG containing desired
%                             external calibration dataset
%   'useBoundary'           - [0|1] turn off/on option to clean while
%                             respecting boundary events
%   'filtXtype'             - ['no'|'LP'|'HP'|'BP'|'Notch'] type of
%                             filter used on X channels.
%   'filtXfreq'             - the cutoff frequency(s) of the specfied X filter.
%   'filtYtype'             - ['no'|'LP'|'HP'|'BP'|'Notch'] type of
%                             filter used on Y channels.
%   'filtYfreq'             - the cutoff frequency(s) of the specfied Y filter. 
%    
% Outputs:
%   OUTEEG  - output dataset
%
% See also:
%   iCanClean, EEGLAB 

% Copyright (C) <2020-2023>  <Ryan Downey>
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
% Please note that this software implements patented methods as described in:
%
% "Removing Latent Noise Components from Data Signals," patent pending, 
% non-provisional patent application submitted to United States Patent and 
% Trademark Office on August 25, 2021, Application No. PCT/US21/71283. 
% Published under International Publication No. WO 2022/061322 on March 24,
%  2022. https://patents.google.com/patent/WO2022061322A1/
%
% and in 
%
% “Using Pseudo Reference Noise Signals to Remove Latent Noise From 
% Data Signals and Identify Data Sources,” sole inventor, patent pending, 
% provisional patent application submitted to United States Patent and 
% Trademark Office on September 5, 2023, Serial No. 63/580,664.
%
% For licensing information, please contact the Univeristy of Florida's
% Tech Licensing center. Contact information below.
%
%
% Physical Address:
% UF Innovate | Tech Licensing
% 747 Southwest 2nd Avenue, Suite 108
% Gainesville, FL 32601
%
% Mailing Address:
% UF Innovate | Tech Licensing
% P.O. Box 115575
% Gainesville, FL 32611-5575
%
% Phone Number:
% (352) 392-8929
%
% Website
% https://innovate.research.ufl.edu/tech-licensing/

function [EEG, com] = pop_iCanClean(EEG, typeproc, varargin)%param3 )

% the command output is a hidden output that does not have to
% be described in the header

com = ''; % this initialization ensure that the function will return something
          % if the user press the cancel button            

% display help if not enough arguments
% ------------------------------------
if nargin < 2
	help pop_iCanClean;
	return;
end

% pop up window
% -------------
if nargin < 3
%% pre-defined geometry
    hrow = [2.75 0.25];
    geometry = {[0.75 0.75 1.5] ...
                1 ...
                [1 0.75 0.25 0.3 0.5 0.2] ... %define corrupted data
                1 ...
                [1 0.75 0.25 0.3 0.5 0.2] ... %define noise signals
                [1 2] ...
                1 ...
                hrow ...    %temp filtering [0.25 0.35 1.35 1.05] ...
                [0.25 0.6 0.5 0.25 0.375 0.325 0.375 0.325] ... %[0.25 0.5 0.875 0.5 0.75 0.125] ...
                1 ...
                [0.25 0.6 0.5 0.25 0.375 0.325 0.375 0.325] ... %[0.25 0.4 0.1 0.3 0.3 0.275 0.4 0.1 0.3 0.3 0.15 0.125] ...
                1 ...
                hrow ...    %pre-calc CCA
                [0.25 0.6 0.5 0.25 0.6 0.25 0.55] ...
                1 ...
                hrow ...    %run stats
                [0.25 0.75 0.5 1.5] ...
                [0.25 0.75 0.5 0.5 1] ...
                [0.25 0.75 0.5 0.5 1] ...
                [0.25 0.75 1 1] ...
                1 ...
                hrow ...    %remove noise
                [0.25 1 0.25 1.5]...
                [0.25 1 0.5 1.25]...
                [0.25 1 0.5 1.25]...
                1 ...
                hrow ...    %other options
                [0.25 2.75]...
                [0.25 2.75]...
                [0.25 2.75]...
                [0.25 2.75]...
                1 ...
                };
    hvrt = 1.1;
    svrt = 0.2;
    geomvert = [1 svrt ...
                hvrt svrt ...               %define corrupted data
                hvrt 1 svrt ...             %define noise signals
                hvrt 1 0.1 1 svrt ...       %temp filtering
                hvrt 1 svrt ...             %pre-calc CCA
                hvrt 1 1 1 1 svrt ...       %run stats
                hvrt 1 1 1 svrt ...         %remove noise
                hvrt 1 1 1 1 svrt ...       %other options
                ];
            
%% pre-fill conditions
    chanTypes = unique({EEG.chanlocs.type});
    if(length(chanTypes)==2 && ismember('EEG',chanTypes))
        noisePrefill = chanTypes{~strcmp('EEG',chanTypes)};
    else
        noisePrefill = fastif(ismember('Noise',chanTypes),'Noise','');
    end

%% pre-defined callbacks
	cb_Xchan = ['tmpchanlocs = EEG(1).chanlocs;' ...
            '[tmp tmpval] = pop_chansel({tmpchanlocs.labels},''withindex'',''on'');' ...
            'set(findobj(gcbf, ''tag'', ''EEG_chans''), ''string'',tmpval);' ...
            'clear tmp tmpchanlocs tmpval'];
    cb_Xtype = strrep(cb_Xchan,'labels},''withindex'',''on','type},''field'',''type');
    cb_Xswitch = ['set(findobj(gcbf, ''tag'', ''Xbutton''), ''callback'',' ... 
            'fastif(get(findobj(gcf,''tag'',''Xbool''),''value'')==2,''' ...
            strrep(cb_Xchan,'''','''''') ''',''' strrep(cb_Xtype,'''','''''') '''));'];
    cb_Ytype = strrep(cb_Xtype,'X','Y');
    cb_Yswitch = strrep(cb_Xswitch,'X','Y');
    cb_windowType = ['set(findobj(gcbf,''tag'',''statsWindow''),''string'',fastif(get(findobj(gcf,''tag'',''windowType''),''value'')==1,''2'',''inf''));', ...
                     'set(findobj(gcbf,''tag'',''cleanWindow''),''string'',fastif(get(findobj(gcf,''tag'',''windowType''),''value'')==1,''1'',''inf''));', ...
                     'set(findobj(gcbf,''tag'',''statsWindow''),''enable'',fastif(get(findobj(gcf,''tag'',''windowType''),''value'')==1,''on'',''off''));', ...
                     'set(findobj(gcbf,''tag'',''cleanWindow''),''enable'',fastif(get(findobj(gcf,''tag'',''windowType''),''value'')==1,''on'',''off''));', ...
                     'set(findobj(gcbf,''tag'',''RTBool''),''enable'',fastif(get(findobj(gcf,''tag'',''windowType''),''value'')==1,''on'',''off''));', ...
                     'set(findobj(gcbf,''tag'',''RTBool''),''value'',0);'];
    % 2022-05-31 NOTE: callbacks for rerefX and rerefY are outdated, they
    % should be removed entirely in the future.
    cb_rerefX = 'set(findobj(gcbf, ''tag'', ''Xrank''), ''enable'',fastif(get(findobj(gcf,''tag'',''rerefX''),''value'')>1,''on'',''off''));';
    cb_rerefY = strrep(cb_rerefX,'X','Y');
    cb_Yself = ['set(findobj(gcbf,''tag'',''Noise_chans''),''string'', fastif(get(findobj(gcbf,''tag'',''Yselfref''),''value''), get(findobj(gcbf,''tag'',''EEG_chans''),''string''), get(findobj(gcbf,''tag'',''Noise_chans''),''string'')));',...
                'set(findobj(gcbf,''tag'',''Noise_chans''),''enable'', fastif(get(findobj(gcbf,''tag'',''Yselfref''),''value''), ''off'', ''on''));',...
                'set(findobj(gcbf,''tag'',''Ybutton''),''enable'', fastif(get(findobj(gcbf,''tag'',''Yselfref''),''value''), ''off'', ''on''));',...
                'set(findobj(gcbf,''tag'',''Ybool''),''enable'', fastif(get(findobj(gcbf,''tag'',''Yselfref''),''value''), ''off'', ''on''));'];
    cb_tempReref = ['set(findobj(gcbf, ''tag'', ''rerefX''),    ''enable'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),''on'',''off''));',...
                    'set(findobj(gcbf, ''tag'', ''filtXtype''), ''enable'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),''on'',''off''));',...
                    'set(findobj(gcbf, ''tag'', ''filtXfreq''),''enable'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),''on'',''off''));',...
                    'set(findobj(gcbf, ''tag'', ''rerefY''),    ''enable'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),''on'',''off''));',...
                    'set(findobj(gcbf, ''tag'', ''filtYtype''), ''enable'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),''on'',''off''));',...
                    'set(findobj(gcbf, ''tag'', ''filtYfreq''),''enable'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),''on'',''off''));',...
                    'set(findobj(gcbf, ''tag'', ''tempLabel''),''enable'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),''on'',''off''));',...
                    'set(findobj(gcbf, ''tag'', ''rerefX''),    ''value'', fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),get(findobj(gcbf,''tag'',''rerefX''),    ''value''),1));',...
                    'set(findobj(gcbf, ''tag'', ''filtXtype''), ''value'', fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),get(findobj(gcbf,''tag'',''filtXtype''), ''value''),1));',...
                    'set(findobj(gcbf, ''tag'', ''filtXfreq''),''string'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),get(findobj(gcbf,''tag'',''filtXfreq''),''string''),''''));',...
                    'set(findobj(gcbf, ''tag'', ''rerefY''),    ''value'', fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),get(findobj(gcbf,''tag'',''rerefY''),    ''value''),1));',...
                    'set(findobj(gcbf, ''tag'', ''filtYtype''), ''value'', fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),get(findobj(gcbf,''tag'',''filtYtype''), ''value''),1));',...
                    'set(findobj(gcbf, ''tag'', ''filtYfreq''),''string'',fastif(get(findobj(gcf,''tag'',''tempReref''),''value''),get(findobj(gcbf,''tag'',''filtYfreq''),''string''),''''));'];
    cb_filtXtype = ['freqs = {'''',''5'',''25'',''55 65'',''5 25''};',...
                    'set(findobj(gcbf, ''tag'', ''filtXfreq''),''string'',freqs{get(findobj(gcbf,''tag'',''filtXtype''),''value'')});';];
    cb_filtYtype = strrep(cb_filtXtype,'X','Y');
    cb_useExtern = ['set(findobj(gcbf,''tag'',''indExternCalibData''),''enable'',fastif(get(findobj(gcf,''tag'',''useExternCalibData''),''value'')-1,''on'',''off''));',...
                    'set(findobj(gcbf,''tag'',''precLabel2''),        ''enable'',fastif(get(findobj(gcf,''tag'',''useExternCalibData''),''value'')-1,''on'',''off''));',...
                    'set(findobj(gcbf,''tag'',''indExternCalibData''),''string'',fastif(get(findobj(gcf,''tag'',''useExternCalibData''),''value'')-1,get(findobj(gcf,''tag'',''indExternCalibData''),''string''),''1''));'];
    cb_calcCCAonWholeData = ['set(findobj(gcbf,''tag'',''useExternCalibData''),''enable'',fastif(get(findobj(gcf,''tag'',''calcCCAonWholeData''),''value''),''on'',''off''));',...
                   'set(findobj(gcbf,''tag'',''precLabel1''),''enable'',fastif(get(findobj(gcf,''tag'',''calcCCAonWholeData''),''value''),''on'',''off''));',...
                   'set(findobj(gcbf,''tag'',''useExternCalibData''),''value'', fastif(get(findobj(gcf,''tag'',''calcCCAonWholeData''),''value''),get(findobj(gcbf,''tag'',''useExternCalibData''),''value''),1));',...
                   cb_useExtern];
    cb_loadPrevIn = ['homefolder = deblank(evalc(''!echo %USERPROFILE%''));',...
                     'if ~exist(fullfile(homefolder,''iCanClean_options.mat'')), warndlg(''Previous run not found.'',''Cannot load previous inputs''); return; end;',...
                     'load(fullfile(homefolder,''iCanClean_options.mat''));',...
                     'fields = fieldnames(params);',...
                     'try,',...
                     'for i=1:length(fields), set(findobj(gcbf,''tag'',fields{i}),fastif(isnumeric(getfield(params,fields{i})), ''value'', ''string''),getfield(params,fields{i})); end;',...
                     'catch, warndlg(''The options file is from a previous version of iCanClean.'',''Cannot load previous inputs''); end;',...
                     cb_windowType cb_rerefX cb_rerefY cb_Yself cb_tempReref cb_calcCCAonWholeData];
    cb_resetDefaults = ['chanTypes = unique({EEG.chanlocs.type});',...
                        'if(length(chanTypes)==2 && ismember(''EEG'',chanTypes)),',...
                        'noisePrefill = chanTypes{~strcmp(''EEG'',chanTypes)};',...
                        'else, noisePrefill = fastif(ismember(''Noise'',chanTypes),''Noise'',''''); end;',...
                        'defaultStruct = struct(''EEG_chans'',''EEG'',''Xbool'',1,''Noise_chans'',noisePrefill,',...
                        ' ''Ybool'',1,''Yselfref'',0,''tempReref'',0,''rerefX'',1,''filtXtype'',1,',...
                        ' ''filtXfreq'','''',''rerefY'',1,''filtYtype'',1,''filtYfreq'','''',',...
                        ' ''calcCCAonWholeData'',0,''useExternCalibData'',1,''indExternCalibData'',''1'',''windowType'',1,',...
                        ' ''statsWindow'',''2'',''statsUnits'',1,''cleanWindow'',''1'',''cleanUnits'',1,',...
                        ' ''RTBool'',0,''rhoSqThres_source'',''0.85'',''cleanXwith'',1,''cleanYwith'',4,''visualizeResults'',0,',...
                        ' ''giveCleaningUpdates'',1,''plotStatsOn'',1,''useBoundary'',0);',...
                        'fields = fieldnames(defaultStruct);',...
                        'for i=1:length(fields), set(findobj(gcbf,''tag'',fields{i}),fastif(isnumeric(getfield(defaultStruct,fields{i})), ''value'', ''string''),getfield(defaultStruct,fields{i})); end;',...
                        cb_windowType cb_rerefX cb_rerefY cb_Yself cb_tempReref cb_calcCCAonWholeData];
    cb_pumAdj = ['temp = findobj(gcf);' ...
                'for i = 2:length(temp)-2,' ...
                ' v = get(temp(i));' ...
                ' if(strcmp(v.Style,''popupmenu'')),' ...
                '  set(findobj(gcf,''tag'',v.Tag),''position'',v.Position+[0 0.007 0 0]);' ...
                ' end;'...
                'end;'];

%% create uilist
%     cb_debug = '';
    hdrFontSize = 13;
    uilist = { ...
        {'style' 'pushbutton' 'string' 'Use previous inputs' 'callback' cb_loadPrevIn},...
        {'style' 'pushbutton' 'string' 'Reset to defaults' 'callback' cb_resetDefaults},...
        {},...%{'style' 'pushbutton' 'string' 'Button used for debugging (temp)' 'callback' cb_debug},...
        ...
        {},...
        ...
        {'style' 'text' 'string' 'Define Corrupted Data Channels (X)' 'fontweight' 'bold' 'fontsize' hdrFontSize},...
        { 'style', 'edit', 'string', fastif(ismember('EEG',chanTypes),'EEG','') 'tag' 'EEG_chans' }, ...
        { 'style' 'pushbutton' 'string' '...' 'tag' 'Xbutton', ...
          'enable' fastif(isempty(EEG(1).chanlocs), 'off', 'on') ...
          'callback' cb_Xtype }, ...
        { 'style' 'text' 'string' 'Specify by:'},...
        { 'style' 'popupmenu' 'string' 'chan type|chan name' 'tag' 'Xbool', ...
          'callback' cb_Xswitch }, ...
        {},...
        ...
        {},...
        ...
        {'style' 'text' 'string' 'Define Reference Noise Channels (Y)' 'fontweight' 'bold' 'fontsize' hdrFontSize},...
        { 'style', 'edit', 'string', noisePrefill 'tag' 'Noise_chans' }, ...
        { 'style' 'pushbutton' 'string' '...' 'tag' 'Ybutton', ...
          'enable' fastif(isempty(EEG(1).chanlocs), 'off', 'on') ...
          'callback' cb_Ytype }, ...
        { 'style' 'text' 'string' 'Specify by:'},...
        { 'style' 'popupmenu' 'string' 'chan type|chan name' 'tag' 'Ybool', ...
          'callback' cb_Yswitch }, ...
        {},...
        ...
        {},...
        { 'style', 'checkbox', 'string', 'Self reference (copy corrupted data signals)' 'tag' 'Yselfref' ...
          'callback' cb_Yself}, ...
        ...
        {},...
        ...
        {'style' 'checkbox' 'string' ' (optional) Temporary Preprocessing Prior to CCA',...
         'fontsize' hdrFontSize,...
         'tag' 'tempReref' 'callback' cb_tempReref},...
        {},...
        ...
        {},...
        {'style' 'text' 'string' 'Avg. Rereference Data' 'enable' 'off' 'tag' 'tempLabel'},...
        {'style' 'popupmenu' 'string' 'no|yes-fullrank|yes-loserank' 'tag' 'rerefX', ...
         'callback' cb_rerefX 'enable' 'off'}, ...
        {},...
        {'style' 'text' 'string' 'Filter Data' 'enable' 'off' 'tag' 'tempLabel'},...
        {'style' 'popupmenu' 'string' 'no|LP|HP|BP|Notch' 'tag' 'filtXtype' 'enable' 'off',...
         'callback' cb_filtXtype},...
        {'style' 'edit' 'string' '' 'tag' 'filtXfreq' 'enable' 'off'}, ...
        {'style' 'text' 'string' 'Hz' 'enable' 'off' 'tag' 'tempLabel'},...
        ...
        {},...
        ...
        {},...
        {'style' 'text' 'string' 'Avg. Rereference Noise' 'enable' 'off' 'tag' 'tempLabel'},...
        {'style' 'popupmenu' 'string' 'no|yes-fullrank|yes-loserank' 'tag' 'rerefY', ...
         'callback' cb_rerefY 'enable' 'off'}, ...
        {},...
        {'style' 'text' 'string' 'Filter Noise' 'enable' 'off' 'tag' 'tempLabel'},...
        {'style' 'popupmenu' 'string' 'no|LP|HP|BP|Notch' 'tag' 'filtYtype' 'enable' 'off',...
         'callback' cb_filtYtype},...
        {'style' 'edit' 'string' '' 'tag' 'filtYfreq' 'enable' 'off'}, ...
        {'style' 'text' 'string' 'Hz' 'enable' 'off' 'tag' 'tempLabel'},...
        ...
        {},...
        ...
        {'style' 'checkbox' 'string' ' (optional) Pre-calculate CCA Unmixing Matrices (A,B) using Calibration Data',...
         'fontsize' hdrFontSize,...
         'tag' 'calcCCAonWholeData' 'callback' cb_calcCCAonWholeData},...
        {},...
        ...
        {},...
        {'style' 'text' 'string' 'Calibration dataset:' 'enable' 'off' 'tag' 'precLabel1'},...
        {'style' 'popupmenu' 'string' 'current|external' 'tag' 'useExternCalibData' 'enable' 'off' 'callback' cb_useExtern},...
        {},...
        {'style', 'text', 'string', 'Specify ALLEEG index:' 'enable' 'off' 'tag' 'precLabel2'}, ...
        {'style', 'edit', 'string', '1'  'tag' 'indExternCalibData' 'enable' 'off'}, ...
        {},...
        ...
        {},...
        ...
        {'style' 'text' 'string' 'Identify Candidate Noise Components (U,V)' 'fontweight' 'bold' 'fontsize' hdrFontSize},...
        {},...
        ...
        {},...
        { 'style', 'text', 'string', 'Window type:' }, ...
        { 'style', 'popupmenu', 'string', 'moving|fixed' 'tag' 'windowType', ...
          'callback' cb_windowType }, ...
        {}, ...
        ...
        {},...
        { 'style', 'text', 'string', '    Stats window length:' }, ...
        { 'style', 'edit', 'string', '2' 'tag' 'statsWindow' }, ...
        { 'style', 'popupmenu', 'string', 'seconds|samples' 'tag' 'statsUnits'}, ...
        {},...
        ...
        {},...
        { 'style', 'text', 'string', '    Cleaning window length:' }, ...
        { 'style', 'edit', 'string', '1' 'tag' 'cleanWindow' }, ...
        { 'style', 'popupmenu', 'string', 'seconds|samples' 'tag' 'cleanUnits'}, ...
        {},...
        ...
        {},...
        { 'style', 'text', 'string', '    Simulate real-time?'}, ...
        { 'style', 'checkbox', 'string', '' 'tag' 'RTBool'}, ...
        {}, ...
        ...
        {},...
        ...
        {'style' 'text' 'string' 'Remove Bad Components' 'fontweight' 'bold' 'fontsize' hdrFontSize},...
        {},...
        ...
        {},...
        { 'style', 'text', 'string', ['Remove noise components with R',char(178),' >'] }, ... %sprintf('<HTML>Remove noise components with R<SUP>%i</SUP> >',2)
        { 'style', 'edit', 'string', '0.85' 'tag' 'rhoSqThres_source' }, ...
        { 'style', 'text' 'string' 'valid range 0-1 (0=most aggressive, 1=least aggressive)'},...
        ...
        {},...
        { 'style', 'text', 'string', 'Clean data channels using mixtures of' }, ...
        { 'style', 'popupmenu', 'string', 'Data|Reference Noise|Data+Reference Noise' 'tag' 'cleanXwith' }, ...
        { 'style' 'text' 'string' 'channels'},...
        ...
        {},...
        { 'style', 'text', 'string', 'Clean noise channels using mixtures of' }, ...
        { 'style', 'popupmenu', 'string', 'Data|Reference Noise|Data+Reference Noise|No' 'tag' 'cleanYwith' 'value' 4}, ...
        { 'style' 'text' 'string' 'channels'}, ...
        ...
        {},...
        ...
        {'style' 'text' 'string' 'Other Options' 'fontweight' 'bold' 'fontsize' hdrFontSize},...
        {},...
        ...
        {},...
        { 'style', 'checkbox', 'string', 'Visualize results' ...
          'tag' 'visualizeResults' 'enable' fastif(exist('vis_artifacts','file')==2,'on','off') ...
          'callback' ['visStr = fastif(exist(''vis_artifacts'',''file'')~=2 && ' ...
            'get(findobj(gcf,''tag'',''visualizeResults''),''value''),' ...
            '''warning(''''ASR toolbox vis_artifacts not found.'''')'','''');' ...
            'eval(visStr); clear visStr'],...
          'value' 1}, ... 
        ...
        {},...
        { 'style', 'checkbox', 'string', 'Give cleaning updates' 'tag' 'giveCleaningUpdates' ...
          'value' 1}, ...
        ...
        {},...
        { 'style', 'checkbox', 'string', ['Plot R',char(178),' correlation'] 'tag' 'plotStatsOn' ... %sprintf('<HTML>Plot R<SUP>%i</SUP> correlation',2)
          'value' 1}, ...
        ...
        {},...
        { 'style', 'checkbox', 'string', 'Respect boundary events' 'tag' 'useBoundary'}, ...
        ...
        {},...
        };

%% pop-up menu
    [~, ~, ~, params] = inputgui('geometry',geometry,'geomvert',geomvert,...
                                 'uilist',uilist,'helpcom','pophelp(''pop_iCanClean'')',...
                                 'title','iCanClean','eval',cb_pumAdj,'skipline','off');
    
%% parse inputs 
    if(isempty(params)), return; end
    homefolder = deblank(evalc('!echo %USERPROFILE%'));
    save(fullfile(homefolder,'iCanClean_options.mat'),'params'); %save previous run
    
    EEG_chans = str2num(params.EEG_chans); %#ok<ST2NM>
    Noise_chans = str2num(params.Noise_chans); %#ok<ST2NM>
    if isempty(EEG_chans)
        try    [EEG_chans, ~] = eeg_decodechan(EEG(1).chanlocs, params.EEG_chans, 'type');
        catch, [EEG_chans, ~] = eeg_decodechan(EEG(1).chanlocs, params.EEG_chans, 'labels');
        end
    end
    if isempty(Noise_chans)
        try    [Noise_chans, ~] = eeg_decodechan(EEG(1).chanlocs, params.Noise_chans, 'type');
        catch, [Noise_chans, ~] = eeg_decodechan(EEG(1).chanlocs, params.Noise_chans, 'labels');
        end
    end
    params.EEG_chans = EEG_chans;
    params.Noise_chans = Noise_chans;
    rerefOpts = {'no','yes-fullrank','yes-loserank'};
    params.rerefX = rerefOpts{params.rerefX};
    params.rerefY = rerefOpts{params.rerefY};
    cleanOpts = {'X','Y','XY','no'};
    params.cleanXwith = cleanOpts{params.cleanXwith}; 
    params.cleanYwith = cleanOpts{params.cleanYwith};
    params.statsWindow = str2double(params.statsWindow);
    params.cleanWindow = str2double(params.cleanWindow);
    if(params.statsUnits == 2),params.statsWindow = params.statsWindow*0.002;end
    if(params.cleanUnits == 2),params.cleanWindow = params.cleanWindow*0.002;end
    if(params.cleanWindow > params.statsWindow),error('Error: cleaning window cannot be greater than stats window');end
    params.rhoSqThres_source = str2double(params.rhoSqThres_source);
    params.useExternCalibData = params.useExternCalibData-1;
    params.indExternCalibData = str2num(params.indExternCalibData); %#ok<ST2NM>
    filtOpts = {'no','LP','HP','BP','Notch'};
    params.filtXtype = filtOpts{params.filtXtype}; 
    params.filtXfreq = str2num(params.filtXfreq); %#ok<ST2NM>
    params.filtYtype = filtOpts{params.filtYtype}; 
    params.filtYfreq = str2num(params.filtYfreq); %#ok<ST2NM>
    
    %remove gui-only tags
    params = rmfield(params,'Xbool');
    params = rmfield(params,'Ybool');
    params = rmfield(params,'Yselfref');
    params = rmfield(params,'tempReref');
    params = rmfield(params,'statsUnits');
    params = rmfield(params,'cleanUnits');
    params = rmfield(params,'windowType');
    
else
    %% new field list 2022-08-15
    fieldlist = ...
        {'EEG_chans'            'integer'   []                                      []      ;...
         'Noise_chans'          'integer'   []                                      []      ;...
         'visualizeResults'     'boolean'   []                                      1       ;...
         'rerefX'               'string'    {'no' 'yes-fullrank' 'yes-loserank'}    'no'    ;...
         'rerefY'               'string'    {'no' 'yes-fullrank' 'yes-loserank'}    'no'    ;...
         'cleanXwith'           'string'    {'X' 'Y' 'XY'}                          'X'     ;...
         'cleanYwith'           'string'    {'X' 'Y' 'XY' 'no'}                     'Y'     ;...
         'cleanWindow'          'real'      []                                      1       ;...
         'RTBool'               'boolean'   []                                      0       ;...
         'statsWindow'          'real'      []                                      2       ;...
         'rhoSqThres_source'    'real'      [0 1]                                   0.85    ;...
         'giveCleaningUpdates'  'boolean'   []                                      1       ;...
         'plotStatsOn'          'boolean'   []                                      1       ;...
         'calcCCAonWholeData'   'boolean'   []                                      0       ;...
         'useExternCalibData'   'boolean'   []                                      0       ;...
         'indExternCalibData'   'integer'   []                                      1       ;...
         'useBoundary'          'boolean'   []                                      0       ;...
         'filtXtype'            'string'    {'no' 'LP' 'HP' 'BP' 'Notch'}           'no'    ;...
         'filtXfreq'            'real'      []                                      []      ;...
         'filtYtype'            'string'    {'no' 'LP' 'HP' 'BP' 'Notch'}           'no'    ;...
         'filtYfreq'            'real'      []                                      []      ;...
        };
        params = finputcheck( varargin, fieldlist ); %need to make this variable for the gui case
        
end

% call function iCanClean either on raw data or ICA data
% ------------------------------------------------------
if typeproc == 1
    EEG = iCanClean(EEG,params.EEG_chans,params.Noise_chans,params.visualizeResults,params);
%     EEG = iCanClean(EEG,params);
else
    if ~isempty( EEG.icadata )
        iCanClean( EEG.icadata );
    else
        error('You must run ICA first');
    end
end

% hide defaults
% -------------
defaultParams = struct('rerefX','no','filtXtype','no','filtXfreq',[],...
                       'rerefY','no','filtYtype','no','filtYfreq',[],...
                       'calcCCAonWholeData',0,'useExternCalibData',0,'indExternCalibData',1,...
                       'statsWindow',2,'cleanWindow',[],'RTBool',0,'rhoSqThres_source',0.85,...
                       'cleanXwith','X','cleanYwith','no','visualizeResults',1,...
                       'giveCleaningUpdates',1,'plotStatsOn',1,'useBoundary',0);

%defaultParams = iCanClean_setParams(params); %could be a smarter, more robust alternative in the future? has not been tested

defaultFields = fields(defaultParams);
for i = 1:length(defaultFields)
    if isequal(params.(defaultFields{i}), defaultParams.(defaultFields{i}))
        params = rmfield(params,defaultFields{i});
    end
end

% return the string command
% -------------------------
paramList=[fieldnames(params).'; struct2cell(params).'];
paramList=paramList(:).';
com = sprintf( 'EEG = pop_iCanClean(EEG, %d, %s);', typeproc, vararg2str( paramList ));
return
